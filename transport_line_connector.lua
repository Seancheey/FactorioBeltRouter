---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
--- Terminology:
---     targetBelt/sourceBelt: If belt A is point towards belt B, then belt B is the targetBelt of A. reversely, belt A is belt B's sourceBelt
---     |->| |->| |->| for this situation, in terms of the belt in the middle, the 1st belt is its sourceBelt, and 3rd is its targetBelt

local assertNotNull = require("__MiscLib__/assert_not_null")
--- @type Logger
local logging = require("__MiscLib__/logging")
--- @type ArrayList
local ArrayList = require("__MiscLib__/array_list")
--- @type MinHeap
local MinHeap = require("__MiscLib__/minheap")
--- @type Vector2D
local Vector2D = require("__MiscLib__/vector2d")
local release_mode = require("release")
--- @type EntityRoutingAttribute
local EntityRoutingAttribute = require("entity_routing_attribute")
--- @type PathUnit
local PathUnit = require("path_unit")
local DirectionHelper = {}
--- @type TransportLineType
local TransportLineType = require("enum/line_type")

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.targetPositionOf(entity)
    return DirectionHelper.targetPosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.targetPosition(position, direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north)
end

--- @param position Vector2D
--- @param getEntityFunc fun()
--- @return LuaEntity[] | ArrayList
function DirectionHelper.neighboringEntities(position, getEntityFunc)
    local entities = ArrayList.new()
    for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
        local entity = getEntityFunc(Vector2D.fromDirection(direction) + position)
        if entity ~= nil then
            entities:add(entity)
        end
    end
    return entities
end

--- Transport chain is an intermediate generated backward linked list that represents a whole transport line.
--- Each node in this linked list represents either one belt, or a pair of underground belt. (in this case the "entity" field represents the input belt, and output belt is inferred by entityDistance + direction)
--- @class TransportChain
--- @field pathUnit PathUnit
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @field leftCumulativeTurns number can't be negative, if ever >=3, we enforce collision check
--- @field rightCumulativeTurns number can't be negative, if ever >=3, we enforce collision check
--- @field enforceCollisionCheck boolean if true, we must check if the transport chain collide with any of previous chain
--- @type TransportChain
local TransportChain = {}
TransportChain.__index = TransportChain

--- @param pathUnit PathUnit
--- @param prevChain TransportChain
--- @param preferOnGround boolean if enabled, will apply A* distance punishment to underground belts
--- @return TransportChain
function TransportChain.new(pathUnit, prevChain, preferOnGround)
    assertNotNull(pathUnit)
    local unitDistance = pathUnit.distance
    -- if prefer on ground, punish underground belts
    if unitDistance > 1 then
        if preferOnGround then
            unitDistance = 2 * unitDistance
        else
            unitDistance = unitDistance * 0.999999
        end
    end
    -- reward a little to to not turning
    if prevChain and pathUnit.direction == prevChain.pathUnit.direction then
        unitDistance = unitDistance - 0.000001
    end
    if prevChain then
        local directionDifference = (pathUnit.direction - prevChain.pathUnit.direction + 4) % 8 - 4
        local leftTurnNum = prevChain.leftCumulativeTurns
        local rightTurnNum = prevChain.rightCumulativeTurns
        local enforceCollisionCheck = prevChain.enforceCollisionCheck
        if not enforceCollisionCheck then
            if directionDifference == 2 then
                -- right turn
                rightTurnNum = rightTurnNum + 1
                leftTurnNum = leftTurnNum == 0 and leftTurnNum or leftTurnNum - 1
            elseif directionDifference == -2 then
                -- left turn
                leftTurnNum = leftTurnNum + 1
                rightTurnNum = rightTurnNum == 0 and rightTurnNum or rightTurnNum - 1
            end
            -- if turn num >= 3, it means there is a possibility for the transport line to form a circle and thus have a chance of self-colliding
            if rightTurnNum >= 3 or leftTurnNum >= 3 then
                enforceCollisionCheck = true
            end
        end
        return setmetatable({
            pathUnit = pathUnit,
            prevChain = prevChain,
            cumulativeDistance = (prevChain.cumulativeDistance + unitDistance) or 0,
            enforceCollisionCheck = enforceCollisionCheck,
            leftCumulativeTurns = leftTurnNum,
            rightCumulativeTurns = rightTurnNum
        }, TransportChain)
    else
        return setmetatable({
            pathUnit = pathUnit,
            prevChain = prevChain,
            cumulativeDistance = 0,
            leftCumulativeTurns = 0,
            rightCumulativeTurns = 0,
            enforceCollisionCheck = false
        }, TransportChain)
    end
end

--- @param placeFunc fun(entity: LuaEntityPrototype)
function TransportChain:placeAllEntities(placeFunc)
    local transportChain = self
    local place = function(entity)
        if transportChain.prevChain ~= nil then
            placeFunc(entity)
        end
    end
    while transportChain ~= nil do
        for _, entitySpec in ipairs(transportChain.pathUnit:toEntitySpecs()) do
            place(entitySpec)
        end
        transportChain = transportChain.prevChain
    end
end

--- Represents the dictionary of minimum travel distance from endingEntity to some belt (represented by a position vector + direction)
--- @class MinDistanceDict
--- @type MinDistanceDict
local MinDistanceDict = {}
MinDistanceDict.__directionNum = 8
MinDistanceDict.__index = MinDistanceDict

--- @return MinDistanceDict
function MinDistanceDict.new()
    return setmetatable({}, MinDistanceDict)
end

function MinDistanceDict.__marshalize(vector, direction)
    return tostring(vector.x) .. '|' .. tostring(vector.y) .. '|' .. tostring(direction)
end

function MinDistanceDict.__unmarshalize(key)
    local sep1 = string.find(key, '|')
    local x = string.sub(key, 1, sep1 - 1)
    local sep2 = string.find(key, '|', sep1 + 1)
    local y = string.sub(key, sep1 + 1, sep2 - 1)
    local direction = string.sub(key, sep2 + 1, -1)
    return Vector2D.new(tonumber(x), tonumber(y)), tonumber(direction)
end

--- @param vector Vector2D
function MinDistanceDict:put(vector, direction, val)
    assertNotNull(self, vector, direction, val)
    local key = MinDistanceDict.__marshalize(vector, direction)
    self[key] = val
end

--- @return number
function MinDistanceDict:get(vector, direction)
    assertNotNull(self, vector, direction)

    return self[MinDistanceDict.__marshalize(vector, direction)]
end

--- @param f fun(key1:vector, key2: defines.direction, val:number)
function MinDistanceDict:forEach(f)
    for key, val in pairs(self) do
        local vector, direction = MinDistanceDict.__unmarshalize(key)
        f(vector, direction, val)
    end
end

--- An "Abstract" transport line connector
--- @class TransportLineConnector
--- @field asyncTaskManager AsyncTaskManager
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntityFunc fun(entity: LuaEntityPrototype)
--- @field getEntityFunc fun(position: Vector2D): LuaEntity
--- @field greedyLevel number
--- @type TransportLineConnector
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @param placeEntityFunc fun(entity: LuaEntityPrototype)
--- @param getEntityFunc fun(position: Vector2D): LuaEntity
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    assertNotNull(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc,
              getEntityFunc = getEntityFunc,
              asyncTaskManager = asyncTaskManager,
              greedyLevel = 1.05 -- just a initial value, will be overridden by player's own setting
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferOnGround boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param asyncTaskManager AsyncTaskManager
--- @param additionalConfig LineConnectConfig optional
--- @param player LuaPlayer optional, player to inform when building finished
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, asyncTaskManager, additionalConfig, player)
    assertNotNull(self, startingEntity, endingEntity)
    local function reportToPlayer(text)
        if player then
            player.print(text)
        end
    end
    if not startingEntity.valid then
        reportToPlayer { "error-message.starting-entity-not-valid" }
        return
    end
    if not endingEntity.valid then
        reportToPlayer { "error-message.ending-entity-not-valid" }
        return
    end
    local entityName = startingEntity.name
    if entityName == "entity-ghost" then
        entityName = startingEntity.ghost_name
    end
    local onGroundVersion = EntityRoutingAttribute.from(entityName).groundEntityPrototype
    if onGroundVersion == nil then
        reportToPlayer { "error-message.find-line-group-failed", { startingEntity.name } }
        return
    end
    local startingUnit = PathUnit:fromLuaEntity(startingEntity)
    local endingUnit = PathUnit:fromLuaEntity(endingEntity, true)

    local allowUnderground, preferOnGround = self:parseConfig(additionalConfig)
    local minDistanceDict = MinDistanceDict.new()
    local priorityQueue = MinHeap.new()
    self.greedyLevel = settings.get_player_settings(player)["greedy-level"].value

    -- Here starts the main logic of function
    local startingEntityTargets = startingUnit:possibleNextPathUnits(false)
    local anyUnblocked = false
    for _, target in ipairs(startingEntityTargets) do
        if self.canPlaceEntityFunc(target.position) then
            anyUnblocked = true
            break
        end
    end
    if not anyUnblocked then
        reportToPlayer { "error-message.starting-entity-blocked" }
        return
    end
    local startingEntityTargetPos = EntityRoutingAttribute.from(startingUnit.name).lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(startingUnit) or startingUnit.position
    -- A* algorithm starts from endingUnit so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingUnit))
    local maxTryNum = settings.get_player_settings(player)["max-path-finding-explore-num"].value
    local batchSize = settings.get_player_settings(player)["path-finding-test-per-tick"].value
    local totalTryNum = 0
    local taskPriority = game.tick
    local function tryFindPath()
        local foundPath = false
        local tryNum = 0
        while not priorityQueue:isEmpty() and tryNum < batchSize and not foundPath do
            --- @type TransportChain
            local transportChain = priorityQueue:pop().val
            if tryNum == 0 then
                player.create_local_flying_text { text = { "info-message.path-find-tag" }, position = transportChain.pathUnit.position, time_to_live = 15 }
            end
            if startingUnit:canConnect(transportChain.pathUnit) then
                transportChain:placeAllEntities(self.placeEntityFunc)
                logging.log("Path find algorithm explored " .. tostring(totalTryNum + tryNum) .. " blocks to find solution")
                foundPath = true
            end
            for _, newChain in pairs(self:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingUnit, preferOnGround)) do
                priorityQueue:push(self:estimateDistance(newChain.pathUnit, startingEntityTargetPos, startingUnit.direction) + newChain.cumulativeDistance, newChain)
            end
            tryNum = tryNum + 1
        end
        totalTryNum = totalTryNum + tryNum
        if not foundPath then
            if priorityQueue:isEmpty() then
                self:debug_visited_position(minDistanceDict)
                reportToPlayer { "error-message.path-find-terminated-early" }
            elseif totalTryNum >= maxTryNum then
                self:debug_visited_position(minDistanceDict)
                reportToPlayer { "error-message.maximum-trial-reached", tostring(maxTryNum) }
            else
                asyncTaskManager:pushTask(tryFindPath, taskPriority)
            end
        end
    end
    asyncTaskManager:pushTask(tryFindPath, taskPriority)
end

--- @param transportChain TransportChain
--- @return TransportChain[]
function TransportLineConnector:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingEntity, preferOnGround)
    assertNotNull(self, transportChain, minDistanceDict, allowUnderground, startingEntity, preferOnGround)

    local candidates = transportChain.pathUnit:possiblePrevPathUnits(allowUnderground, self.canPlaceEntityFunc):map(
            function(pathUnit)
                return TransportChain.new(pathUnit, transportChain, preferOnGround)
            end
    )
    local legalCandidates = ArrayList.new()
    for _, newChain in ipairs(candidates) do
        if self:testCanPlace(newChain, minDistanceDict, startingEntity) then
            legalCandidates:add(newChain)
        end
    end
    return legalCandidates
end

--- @param newChain TransportChain
--- @param minDistanceDict MinDistanceDict
--- @param startingEntity LuaEntitySpec
function TransportLineConnector:testCanPlace(newChain, minDistanceDict, startingEntity)
    assertNotNull(self, newChain, minDistanceDict, startingEntity)
    local pathUnit = newChain.pathUnit
    local entityList = pathUnit:toEntitySpecs()

    for _, entity in ipairs(entityList) do
        if not self.canPlaceEntityFunc(entity.position) then
            return false
        end
    end

    local attribute = EntityRoutingAttribute.from(pathUnit.name)
    if attribute.isUnderground then
        -- make sure there is no interfering underground belts whose direction is parallel to our underground belt pair
        for testDiff = 1, pathUnit.distance - 2, 1 do
            local testPos = pathUnit.position + Vector2D.fromDirection(pathUnit.direction):scale(testDiff)
            local entityInMiddle = self.getEntityFunc(testPos)
            if entityInMiddle
                    and (
                    entityInMiddle.name == pathUnit.name or
                            (entityInMiddle.type == "entity-ghost"
                                    and entityInMiddle.ghost_name == pathUnit.name
                            ))
                    and (((pathUnit.direction or defines.direction.north) - entityInMiddle.direction) % 4) == 0
            then
                logging.log("can't cross other entity facing" .. tostring(entityInMiddle.direction), "placing")
                return false
            end
        end
    end

    local closeToFinal = false
    for _, entity in ipairs(entityList) do
        if attribute.lineType == TransportLineType.itemLine then
            -- Check neighbor belts, make sure they don't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = EntityRoutingAttribute.from(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(neighbor) == entity.position then
                    if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                        logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                        return false
                    else
                        closeToFinal = true
                    end
                end
            end
        elseif attribute:isOnGroundPipe() then
            -- Check neighbor pipes, make sure pipe are not our neighbor and underground pipe doesn't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = EntityRoutingAttribute.from(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.fluidLine then
                    if neighborType:isOnGroundPipe() or DirectionHelper.targetPositionOf(neighbor) == entity.position then
                        if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                            logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                            return false
                        else
                            closeToFinal = true
                        end
                    end
                end
            end
        end
    end

    if newChain.enforceCollisionCheck then
        -- check the transport chain doesn't collide with itself
        -- TODO: although I've optimized this check only to be done when necessary, this is still costly and performance degrades even more for long+curvy path. Any possibility of optimizing even more?
        local testPositions = newChain.pathUnit:toEntitySpecs()
        local testingChain = newChain.prevChain
        while testingChain do
            for _, testSpec in ipairs(testPositions) do
                if testSpec.position == testingChain.pathUnit.position then
                    return false
                end
            end
            testingChain = testingChain.prevChain
        end
    end

    if closeToFinal then
        return true
    else
        -- we only consider those path whose distance could be smaller at the position, like dijkstra algorithm
        local distanceSmallerThanAny = false
        for _, sourceUnit in ipairs(pathUnit:possiblePrevPathUnits(false)) do
            local curMinDistance = minDistanceDict:get(sourceUnit.position, sourceUnit.direction)
            if curMinDistance == nil or curMinDistance > newChain.cumulativeDistance then
                minDistanceDict:put(sourceUnit.position, sourceUnit.direction, newChain.cumulativeDistance)
                distanceSmallerThanAny = true
            end
        end
        if not distanceSmallerThanAny then
            logging.log("distance is no smaller than any at " .. serpent.line(pathUnit.position), "placing")
        end
        return distanceSmallerThanAny
    end
end

--- A* algorithm's heuristics cost
--- @param testPathUnit PathUnit
--- @param targetPos Vector2D
--- @param rewardDirection defines.direction
function TransportLineConnector:estimateDistance(testPathUnit, targetPos, rewardDirection)
    local dx = math.abs(testPathUnit.position.x - targetPos.x)
    local dy = math.abs(testPathUnit.position.y - targetPos.y)
    -- direction becomes increasingly important as belt is closer to starting entity, but reward is no more than 1
    -- We punish reversed direction, and reward same direction
    local directionReward = 0
    if dx + dy <= 5 then
        directionReward = -1 * ((testPathUnit.direction - rewardDirection) % 8 / 2 - 1) / (dx + dy + 1)
    end
    return (dx + dy + 1 - directionReward) * self.greedyLevel -- slightly encourage greedy-first
end

--- @param minDistanceDict MinDistanceDict
function TransportLineConnector:debug_visited_position(minDistanceDict)
    if not release_mode then
        local posDict = {}
        minDistanceDict:forEach(
                function(vector, direction, val)
                    local key = tostring(vector.x) .. "," .. tostring(vector.y)
                    posDict[key] = posDict[key] or { vector = vector, directions = {} }
                    posDict[key].directions[direction] = val
                end)
        local directionMapping = { [0] = "N", [2] = "E", [4] = "S", [6] = "W" }
        for _, dict in pairs(posDict) do
            local vector = dict.vector
            local text = ""
            for direction, val in pairs(dict.directions) do
                text = text .. directionMapping[direction] .. tostring(val)
            end
            game.players[1].create_local_flying_text { text = text, position = vector, time_to_live = 100000, speed = 0.000001 }
        end
    end
end

--- @param additionalConfig LineConnectConfig nullable
--- @return boolean, boolean allowUnderground, preferOnGround
function TransportLineConnector:parseConfig(additionalConfig)
    local allowUnderground = true
    local preferOnGround = false
    if additionalConfig then
        if additionalConfig.allowUnderground ~= nil then
            allowUnderground = additionalConfig.allowUnderground
        end
        if additionalConfig.preferOnGround ~= nil then
            preferOnGround = additionalConfig.preferOnGround
        end
    end
    return allowUnderground, preferOnGround
end

return TransportLineConnector