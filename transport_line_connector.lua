---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
--- Terminology:
---     targetBelt/sourceBelt: If belt A is point towards belt B, then belt B is the targetBelt of A. reversely, belt A is belt B's sourceBelt
---     |->| |->| |->| for this situation, in terms of the belt in the middle, the 1st belt is its sourceBelt, and 3rd is its targetBelt

local assertNotNull = require("__MiscLib__/assert_not_null")
--- @type Logger
local logging = require("__MiscLib__/logging")
--- @type ArrayList
local ArrayList = require("__MiscLib__/array_list")
--- @type MinHeap
local MinHeap = require("__MiscLib__/minheap")
--- @type Vector2D
local Vector2D = require("__MiscLib__/vector2d")
--- @type PrototypeInfo
local PrototypeInfo = require("prototype_info")
local release_mode = require("release")
--- @type TransportLineType
local TransportLineType = require("transport_line_type")
--- @type PathUnit
local PathUnit = require("path_unit")
local DirectionHelper = {}

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.sourcePositionOf(entity)
    return DirectionHelper.sourcePosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.sourcePosition(position, direction)
    assert(position and direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north):reverse()
end

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.targetPositionOf(entity)
    return DirectionHelper.targetPosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.targetPosition(position, direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north)
end

--- @param position Vector2D
--- @param getEntityFunc fun()
--- @return LuaEntity[] | ArrayList
function DirectionHelper.neighboringEntities(position, getEntityFunc)
    local entities = ArrayList.new()
    for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
        local entity = getEntityFunc(Vector2D.fromDirection(direction) + position)
        if entity ~= nil then
            entities:add(entity)
        end
    end
    return entities
end

--- @param entity LuaEntity
--- @return LuaEntity[]|ArrayList entity with only direction and position
function DirectionHelper.legalSourcesOf(entity)
    assert(entity)
    local legalSources = ArrayList.new()
    -- TODO handle pipe situation
    if PrototypeInfo.is_underground_transport(entity.name) then
        -- underground belt's input only allows one direction
        legalSources:add { position = DirectionHelper.sourcePositionOf(entity), direction = entity.direction }
    else
        -- normal belts allows 3 directions
        local banDirection = Vector2D.fromDirection(entity.direction):reverse():toDirection()
        for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
            if direction ~= banDirection then
                legalSources:add { position = DirectionHelper.sourcePosition(entity.position, direction), direction = (direction + 4) % 8 }
            end
        end
    end
    return legalSources
end

--- Transport chain is an intermediate generated backward linked list that represents a whole transport line.
--- Each node in this linked list represents either one belt, or a pair of underground belt. (in this case the "entity" field represents the input belt, and output belt is inferred by entityDistance + direction)
--- @class TransportChain
--- @field pathUnit PathUnit
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @field entity LuaEntity deprecated
--- @type TransportChain
local TransportChain = {}

--- @param pathUnit PathUnit
--- @param prevChain TransportChain
--- @return TransportChain
function TransportChain.new(pathUnit, prevChain)
    assertNotNull(pathUnit)
    return setmetatable({
        pathUnit = pathUnit,
        prevChain = prevChain,
        cumulativeDistance = prevChain and (prevChain.cumulativeDistance + pathUnit.distance) or 0,
    }, { __index = TransportChain })
end

--- @param placeFunc fun(entity: LuaEntityPrototype)
function TransportChain:placeAllEntities(placeFunc)
    local transportChain = self
    local place = function(entity)
        if transportChain.prevChain ~= nil then
            placeFunc(entity)
        end
    end
    while transportChain ~= nil do
        for _, entitySpec in ipairs(transportChain.pathUnit:toEntitySpecs()) do
            place(entitySpec)
        end
        transportChain = transportChain.prevChain
    end
end

--- Represents the dictionary of minimum travel distance from endingEntity to some belt (represented by a position vector + direction)
--- @class MinDistanceDict
--- @type MinDistanceDict
local MinDistanceDict = {}
MinDistanceDict.__directionNum = 8

--- @return MinDistanceDict
function MinDistanceDict.new()
    return setmetatable({}, { __index = MinDistanceDict })
end

function MinDistanceDict.__marshalize(vector, direction)
    return tostring(vector.x) .. '|' .. tostring(vector.y) .. '|' .. tostring(direction)
end

function MinDistanceDict.__unmarshalize(key)
    local sep1 = string.find(key, '|')
    local x = string.sub(key, 1, sep1 - 1)
    local sep2 = string.find(key, '|', sep1 + 1)
    local y = string.sub(key, sep1 + 1, sep2 - 1)
    local direction = string.sub(key, sep2 + 1, -1)
    return Vector2D.new(tonumber(x), tonumber(y)), tonumber(direction)
end

--- @param vector Vector2D
function MinDistanceDict:put(vector, direction, val)
    assertNotNull(self, vector, direction, val)
    local key = MinDistanceDict.__marshalize(vector, direction)
    self[key] = val
end

--- @param entity LuaEntity
function MinDistanceDict:putUsingTargetEntity(entity, val)
    if PrototypeInfo.is_underground_transport(entity.name) then
        -- TODO: also add input underground belt
    end
    self:put(entity.position, entity.direction, val)
end

--- @return number
function MinDistanceDict:get(vector, direction)
    assertNotNull(self, vector, direction)

    return self[MinDistanceDict.__marshalize(vector, direction)]
end

--- @param f fun(key1:vector, key2: defines.direction, val:number)
function MinDistanceDict:forEach(f)
    for key, val in pairs(self) do
        local vector, direction = MinDistanceDict.__unmarshalize(key)
        f(vector, direction, val)
    end
end

--- An "Abstract" transport line connector
--- @class TransportLineConnector
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntityFunc fun(entity: LuaEntityPrototype)
--- @field getEntityFunc fun(position: Vector2D): LuaEntity
--- @type TransportLineConnector
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @param placeEntityFunc fun(entity: LuaEntityPrototype)
--- @param getEntityFunc fun(position: Vector2D): LuaEntity
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc, getEntityFunc)
    assertNotNull(canPlaceEntityFunc, placeEntityFunc, getEntityFunc)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc,
              getEntityFunc = getEntityFunc
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferHorizontal boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param additionalConfig LineConnectConfig optional
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, additionalConfig)
    assertNotNull(self, startingEntity, endingEntity)
    if not startingEntity.valid then
        return "starting line entity is no longer valid"
    end
    if not endingEntity.valid then
        return "ending line entity is no longer valid"
    end
    local onGroundVersion = TransportLineType.onGroundVersionOf(startingEntity.name)
    if not onGroundVersion then
        return "Can't find an above-ground version of this entity"
    end
    --- @type PathUnit
    startingEntity = PathUnit:new {
        name = onGroundVersion.name,
        position = Vector2D.fromPosition(startingEntity.position),
        direction = startingEntity.direction or defines.direction.north,
        distance = 1,
        type = startingEntity.type
    }
    --- @type PathUnit
    endingEntity = PathUnit:new {
        name = endingEntity.name,
        position = Vector2D.fromPosition(endingEntity.position),
        direction = endingEntity.direction or defines.direction.north,
        distance = 1,
        type = endingEntity.type
    }
    -- TODO Special trick to compromise TransportChain underground pipe direction, should change when transport chain is updated
    if TransportLineType.getType(endingEntity.name).lineType == TransportLineType.fluidLine and TransportLineType.getType(endingEntity.name).groundType == TransportLineType.underGround then
        endingEntity.direction = Vector2D.fromDirection(endingEntity.direction):reverse():toDirection()
    end

    local allowUnderground = true
    if additionalConfig and additionalConfig.allowUnderground ~= nil then
        allowUnderground = additionalConfig.allowUnderground
    end
    local preferHorizontal = (additionalConfig and (additionalConfig.preferHorizontal ~= nil)) and additionalConfig.preferHorizontal or true
    local minDistanceDict = MinDistanceDict.new()
    local priorityQueue = MinHeap.new()

    -- Here starts the main logic of function

    local startingEntityTargetPos = TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(startingEntity) or startingEntity.position
    if not self.canPlaceEntityFunc(startingEntityTargetPos) and TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine then
        logging.log("starting entity's target position is blocked")
        return
    end
    -- A* algorithm starts from endingEntity so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingEntity))
    local maxTryNum = 5000
    local tryNum = 0

    --- @return PathUnit[]
    local surroundCandidateFunc = TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine and TransportLineConnector.itemSurroundingCandidates or TransportLineConnector.fluidSurroundingCandidates
    local canTerminateFunc = TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine and
            function(pathUnit)
                local entityType = TransportLineType.getType(pathUnit.name)
                if entityType.beltType == TransportLineType.normalBelt then
                    return pathUnit.position == startingEntityTargetPos and (pathUnit.direction - startingEntity.direction) % 8 <= 2
                elseif entityType.beltType == TransportLineType.undergroundBelt then
                    return pathUnit.position == startingEntityTargetPos and (pathUnit.direction == startingEntity.direction)
                else
                    return false
                end
            end or
            function(pathUnit)
                local groundType = TransportLineType.getType(pathUnit.name).groundType
                if groundType == TransportLineType.onGround then
                    return math.abs(pathUnit.position.x - startingEntity.position.x) + math.abs(pathUnit.position.y - startingEntity.position.y) <= 1
                else
                    return DirectionHelper.sourcePositionOf(pathUnit) == startingEntity.position
                end
            end
    while not priorityQueue:isEmpty() and tryNum < maxTryNum do
        --- @type TransportChain
        local transportChain = priorityQueue:pop().val

        if canTerminateFunc(transportChain.pathUnit) then
            transportChain:placeAllEntities(self.placeEntityFunc)
            logging.log("Path find algorithm explored " .. tostring(tryNum) .. " blocks to find solution")
            return
        end
        for _, pathUnit in pairs(surroundCandidateFunc(self, transportChain, minDistanceDict, game.entity_prototypes[startingEntity.name], allowUnderground, startingEntity)) do
            local newChain = TransportChain.new(pathUnit, transportChain)
            priorityQueue:push(self:estimateDistance(pathUnit:toEntitySpecs()[1], startingEntityTargetPos, startingEntity.direction, preferHorizontal, not preferHorizontal) + newChain.cumulativeDistance, newChain)
        end
        tryNum = tryNum + 1
    end
    if priorityQueue:isEmpty() then
        self:debug_visited_position(minDistanceDict)
        return "Path finding terminated, there is probably no path between the two entity"
    else
        self:debug_visited_position(minDistanceDict)
        return "Failed to connect transport line within " .. tostring(maxTryNum) .. " trials"
    end
    return
end

--- @param basePrototype LuaEntityPrototype transport line's base entity prototype
--- @param transportChain TransportChain
--- @return PathUnit[]
function TransportLineConnector:fluidSurroundingCandidates(transportChain, minDistanceDict, basePrototype, allowUnderground, startingEntity)
    assertNotNull(self, transportChain, basePrototype, allowUnderground)
    local underground_prototype = TransportLineType.undergroundVersionOf(basePrototype.name)
    --- @type PathUnit[]
    local candidates = ArrayList.new()
    local legalDirections
    if PrototypeInfo.is_underground_transport(transportChain.pathUnit.name) then
        -- underground pipe's input only allows one direction
        legalDirections = { [Vector2D.fromDirection(transportChain.pathUnit.direction):reverse():toDirection()] = true }
    else
        -- normal pipe would allow all legal directions
        legalDirections = {
            [defines.direction.north] = true,
            [defines.direction.west] = true,
            [defines.direction.south] = true,
            [defines.direction.east] = true
        }
    end
    for direction, _ in pairs(legalDirections) do
        local directionVector = Vector2D.fromDirection(direction)
        -- test if we can place it underground
        if allowUnderground then
            local targetPos = Vector2D.fromPosition(transportChain.pathUnit.position)
            for underground_distance = underground_prototype.max_underground_distance + 1, 3, -1 do
                candidates:add(PathUnit:new {
                    name = underground_prototype.name,
                    direction = directionVector:reverse():toDirection(),
                    position = directionVector:scale(underground_distance) + targetPos,
                    distance = underground_distance
                })
            end
        end
        -- test if we can place it on ground
        local onGroundPos = directionVector + Vector2D.fromPosition(transportChain.pathUnit.position)
        candidates:add(PathUnit:new {
            name = basePrototype.name,
            direction = 0,
            position = onGroundPos,
            distance = 1
        })
    end
    local legalCandidates = ArrayList.new()
    for _, pathUnit in pairs(candidates) do
        if self:testCanPlace(pathUnit, transportChain.cumulativeDistance + pathUnit.distance, minDistanceDict, startingEntity) then
            legalCandidates:add(pathUnit)
        end
    end
    return legalCandidates
end

--- @param basePrototype LuaEntityPrototype transport line's base entity prototype
--- @param transportChain TransportChain
--- @return PathUnit[]
function TransportLineConnector:itemSurroundingCandidates(transportChain, minDistanceDict, basePrototype, allowUnderground, startingEntity)
    assertNotNull(self, transportChain, basePrototype, allowUnderground)

    local underground_prototype = TransportLineType.undergroundVersionOf(basePrototype.name)
    --- @type PathUnit[]|ArrayList
    local candidates = ArrayList.new()
    --- @type table<defines.direction, boolean>
    local legalDirections
    if PrototypeInfo.is_underground_transport(transportChain.pathUnit.name) then
        -- underground belt's input only allows one direction
        legalDirections = { [Vector2D.fromDirection(transportChain.pathUnit.direction):reverse():toDirection()] = true }
    else
        -- normal belt would allow 3 legal directions
        legalDirections = {
            [defines.direction.north] = true,
            [defines.direction.west] = true,
            [defines.direction.south] = true,
            [defines.direction.east] = true
        }
        legalDirections[transportChain.pathUnit.direction or defines.direction.north] = nil
    end
    for direction, _ in pairs(legalDirections) do
        local directionVector = Vector2D.fromDirection(direction)
        -- test if we can place it underground
        if allowUnderground then
            local targetPos = Vector2D.fromPosition(transportChain.pathUnit.position)
            -- make sure output underground belt can fit into map
            for underground_distance = underground_prototype.max_underground_distance + 1, 3, -1 do
                candidates:add(PathUnit:new {
                    name = underground_prototype.name,
                    direction = directionVector:reverse():toDirection(),
                    position = directionVector:scale(underground_distance) + targetPos,
                    distance = underground_distance
                })
            end
        end
        -- test if we can place it on ground
        local onGroundPos = directionVector + Vector2D.fromPosition(transportChain.pathUnit.position)
        candidates:add(PathUnit:new {
            name = basePrototype.name,
            direction = directionVector:reverse():toDirection(),
            position = onGroundPos,
            distance = 1
        })
    end
    local legalCandidates = ArrayList.new()
    for _, pathUnit in ipairs(candidates) do
        if self:testCanPlace(pathUnit, transportChain.cumulativeDistance + pathUnit.distance, minDistanceDict, startingEntity) then
            legalCandidates:add(pathUnit)
        end
    end
    return legalCandidates
end

--- @param pathUnit PathUnit
--- @param cumulativeDistance number
--- @param minDistanceDict MinDistanceDict
--- @param startingEntity LuaEntitySpec
function TransportLineConnector:testCanPlace(pathUnit, cumulativeDistance, minDistanceDict, startingEntity)
    assertNotNull(self, pathUnit, cumulativeDistance, minDistanceDict, startingEntity)

    local entityType = TransportLineType.getType(pathUnit.name)
    for _, entity in ipairs(pathUnit:toEntitySpecs()) do
        if not self.canPlaceEntityFunc(entity.position) then
            return false
        end
        if entityType.lineType == TransportLineType.itemLine then
            -- Check neighbor belts, make sure they don't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = TransportLineType.getType(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(neighbor) == entity.position then
                    if (neighbor.position - startingEntity.position):l1Norm() > 0.5 then
                        logging.log("can't place at " .. serpent.line(entity.position))
                        return false
                    end
                end
            end
        elseif (entityType.lineType == TransportLineType.fluidLine and entityType.groundType == TransportLineType.onGround) then
            -- Check neighbor pipes, make sure pipe are not our neighbor and underground pipe doesn't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = TransportLineType.getType(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.fluidLine then
                    if neighborType.groundType == TransportLineType.onGround or DirectionHelper.targetPositionOf(neighbor) == entity.position then
                        if (neighbor.position - startingEntity.position):l1Norm() > 0.5 then
                            logging.log("can't place at " .. serpent.line(entity.position))
                            return false
                        end
                    end
                end
            end
        end
    end

    if entityType.groundType == TransportLineType.underGround then
        -- make sure there is no interfering underground belts whose direction is parallel to our underground belt pair
        for testDiff = 1, pathUnit.distance - 2, 1 do
            local testPos = pathUnit.position + Vector2D.fromDirection(pathUnit.direction):scale(testDiff)
            local entityInMiddle = self.getEntityFunc(testPos)
            if entityInMiddle
                    and (
                    entityInMiddle.name == pathUnit.name or
                            (entityInMiddle.type == "entity-ghost"
                                    and entityInMiddle.ghost_name == pathUnit.name
                            ))
                    and (((pathUnit.direction or defines.direction.north) - entityInMiddle.direction) % 4) == 0
            then
                logging.log("can't cross other entity facing" .. tostring(entityInMiddle.direction))
                return false
            end
        end
    end

    -- we only consider those path whose distance could be smaller at the position, like dijkstra algorithm
    local distanceSmallerThanAny = false
    for _, sourceEntity in ipairs(DirectionHelper.legalSourcesOf(pathUnit)) do
        local curMinDistance = minDistanceDict:get(sourceEntity.position, sourceEntity.direction)
        if curMinDistance == nil or curMinDistance > cumulativeDistance then
            minDistanceDict:put(sourceEntity.position, sourceEntity.direction, cumulativeDistance)
            distanceSmallerThanAny = true
        end
    end
    return distanceSmallerThanAny
end

--- A* algorithm's heuristics cost
--- @param testEntity LuaEntity
--- @param targetPos Vector2D
--- @param rewardDirection defines.direction
function TransportLineConnector:estimateDistance(testEntity, targetPos, rewardDirection, rewardHorizontalFirst, rewardVerticalFirst)
    local dx = math.abs(testEntity.position.x - targetPos.x)
    local dy = math.abs(testEntity.position.y - targetPos.y)
    -- break A* cost tie by rewarding going to same x/y-level, but reward is no more than 1
    local positionReward = (rewardHorizontalFirst and (1 / (dy + 1)) or 0) + (rewardVerticalFirst and (1 / (dx + 1)) or 0)
    -- direction becomes increasingly important as belt is closer to starting entity, but reward is no more than 1
    -- We punish reversed direction, and reward same direction
    local directionReward = -1 * ((testEntity.direction - rewardDirection) % 8 / 2 - 1) / (dx + dy + 1)
    logging.log("reward = " .. tostring(positionReward), "reward")
    return (dx + dy - positionReward - directionReward) * 1.05 -- slightly encourage greedy-first
end

--- @param minDistanceDict MinDistanceDict
function TransportLineConnector:debug_visited_position(minDistanceDict)
    if not release_mode then
        local posDict = {}
        minDistanceDict:forEach(
                function(vector, direction, val)
                    local key = tostring(vector.x) .. "," .. tostring(vector.y)
                    posDict[key] = posDict[key] or { vector = vector, directions = {} }
                    posDict[key].directions[direction] = val
                end)
        local directionMapping = { [0] = "N", [2] = "E", [4] = "S", [6] = "W" }
        for _, dict in pairs(posDict) do
            local vector = dict.vector
            local text = ""
            for direction, val in pairs(dict.directions) do
                text = text .. directionMapping[direction] .. tostring(val)
            end
            game.players[1].create_local_flying_text { text = text, position = vector, time_to_live = 100000, speed = 0.000001 }
        end
    end
end

return TransportLineConnector