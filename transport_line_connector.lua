---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
--- Terminology:
---     targetBelt/sourceBelt: If belt A is point towards belt B, then belt B is the targetBelt of A. reversely, belt A is belt B's sourceBelt
---     |->| |->| |->| for this situation, in terms of the belt in the middle, the 1st belt is its sourceBelt, and 3rd is its targetBelt

local assertNotNull = require("__MiscLib__/assert_not_null")
--- @type Logger
local logging = require("__MiscLib__/logging")
--- @type ArrayList
local ArrayList = require("__MiscLib__/array_list")
--- @type MinHeap
local MinHeap = require("__MiscLib__/minheap")
--- @type Vector2D
local Vector2D = require("__MiscLib__/vector2d")
local release_mode = require("release")
--- @type EntityRoutingAttribute
local EntityRoutingAttribute = require("entity_routing_attribute")
--- @type PathUnit
local PathUnit = require("path_unit")
local DirectionHelper = {}
--- @type TransportLineType
local TransportLineType = require("enum/line_type")

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.targetPositionOf(entity)
    return DirectionHelper.targetPosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.targetPosition(position, direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north)
end

--- @param position Vector2D
--- @param getEntityFunc fun()
--- @return LuaEntity[] | ArrayList
function DirectionHelper.neighboringEntities(position, getEntityFunc)
    local entities = ArrayList.new()
    for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
        local entity = getEntityFunc(Vector2D.fromDirection(direction) + position)
        if entity ~= nil then
            entities:add(entity)
        end
    end
    return entities
end

--- Transport chain is an intermediate generated backward linked list that represents a whole transport line.
--- Each node in this linked list represents either one belt, or a pair of underground belt. (in this case the "entity" field represents the input belt, and output belt is inferred by entityDistance + direction)
--- @class TransportChain
--- @field pathUnit PathUnit
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @type TransportChain
local TransportChain = {}

--- @param pathUnit PathUnit
--- @param prevChain TransportChain
--- @param preferOnGround boolean if enabled, will apply A* distance punishment to underground belts
--- @return TransportChain
function TransportChain.new(pathUnit, prevChain, preferOnGround)
    assertNotNull(pathUnit)
    local unitDistance = pathUnit.distance
    if unitDistance > 1 and preferOnGround then
        unitDistance = 2 * unitDistance
    end
    return setmetatable({
        pathUnit = pathUnit,
        prevChain = prevChain,
        cumulativeDistance = prevChain and (prevChain.cumulativeDistance + unitDistance) or 0,
    }, { __index = TransportChain })
end

--- @param placeFunc fun(entity: LuaEntityPrototype)
function TransportChain:placeAllEntities(placeFunc)
    local transportChain = self
    local place = function(entity)
        if transportChain.prevChain ~= nil then
            placeFunc(entity)
        end
    end
    while transportChain ~= nil do
        for _, entitySpec in ipairs(transportChain.pathUnit:toEntitySpecs()) do
            place(entitySpec)
        end
        transportChain = transportChain.prevChain
    end
end

--- Represents the dictionary of minimum travel distance from endingEntity to some belt (represented by a position vector + direction)
--- @class MinDistanceDict
--- @type MinDistanceDict
local MinDistanceDict = {}
MinDistanceDict.__directionNum = 8
MinDistanceDict.__index = MinDistanceDict

--- @return MinDistanceDict
function MinDistanceDict.new()
    return setmetatable({}, MinDistanceDict)
end

function MinDistanceDict.__marshalize(vector, direction)
    return tostring(vector.x) .. '|' .. tostring(vector.y) .. '|' .. tostring(direction)
end

function MinDistanceDict.__unmarshalize(key)
    local sep1 = string.find(key, '|')
    local x = string.sub(key, 1, sep1 - 1)
    local sep2 = string.find(key, '|', sep1 + 1)
    local y = string.sub(key, sep1 + 1, sep2 - 1)
    local direction = string.sub(key, sep2 + 1, -1)
    return Vector2D.new(tonumber(x), tonumber(y)), tonumber(direction)
end

--- @param vector Vector2D
function MinDistanceDict:put(vector, direction, val)
    assertNotNull(self, vector, direction, val)
    local key = MinDistanceDict.__marshalize(vector, direction)
    self[key] = val
end

--- @return number
function MinDistanceDict:get(vector, direction)
    assertNotNull(self, vector, direction)

    return self[MinDistanceDict.__marshalize(vector, direction)]
end

--- @param f fun(key1:vector, key2: defines.direction, val:number)
function MinDistanceDict:forEach(f)
    for key, val in pairs(self) do
        local vector, direction = MinDistanceDict.__unmarshalize(key)
        f(vector, direction, val)
    end
end

--- An "Abstract" transport line connector
--- @class TransportLineConnector
--- @field asyncTaskManager AsyncTaskManager
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntityFunc fun(entity: LuaEntityPrototype)
--- @field getEntityFunc fun(position: Vector2D): LuaEntity
--- @type TransportLineConnector
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @param placeEntityFunc fun(entity: LuaEntityPrototype)
--- @param getEntityFunc fun(position: Vector2D): LuaEntity
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    assertNotNull(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc,
              getEntityFunc = getEntityFunc,
              asyncTaskManager = asyncTaskManager
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferOnGround boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param asyncTaskManager AsyncTaskManager
--- @param additionalConfig LineConnectConfig optional
--- @param player LuaPlayer optional, player to inform when building finished
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, asyncTaskManager, additionalConfig, player)
    assertNotNull(self, startingEntity, endingEntity)
    local function reportToPlayer(text)
        if player then
            player.print(text)
        end
    end
    if not startingEntity.valid then
        reportToPlayer("starting line entity is no longer valid")
        return
    end
    if not endingEntity.valid then
        reportToPlayer("ending line entity is no longer valid")
        return
    end
    local onGroundVersion = EntityRoutingAttribute.from(startingEntity.name).groundEntityPrototype
    if onGroundVersion == nil then
        reportToPlayer("Can't find this entity's associated transport line type")
        return
    end
    local startingUnit = PathUnit:fromLuaEntity(startingEntity)
    local endingUnit = PathUnit:fromLuaEntity(endingEntity, true)

    local allowUnderground, preferOnGround = self:parseConfig(additionalConfig)
    local minDistanceDict = MinDistanceDict.new()
    local priorityQueue = MinHeap.new()

    -- Here starts the main logic of function
    local startingEntityTargets = startingUnit:possibleNextPathUnits(false)
    local anyUnblocked = false
    for _, target in ipairs(startingEntityTargets) do
        if self.canPlaceEntityFunc(target.position) then
            anyUnblocked = true
            break
        end
    end
    if not anyUnblocked then
        reportToPlayer("starting position is blocked. Path finding terminated.")
        return
    end
    local startingEntityTargetPos = EntityRoutingAttribute.from(startingUnit.name).lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(startingUnit) or startingUnit.position
    -- A* algorithm starts from endingUnit so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingUnit))
    local maxTryNum = settings.get_player_settings(player)["max-path-finding-explore-num"].value
    local batchSize = settings.get_player_settings(player)["path-finding-test-per-tick"].value
    local totalTryNum = 0
    local taskPriority = game.tick
    local function tryFindPath()
        local foundPath = false
        local tryNum = 0
        while not priorityQueue:isEmpty() and tryNum < batchSize and not foundPath do
            --- @type TransportChain
            local transportChain = priorityQueue:pop().val
            if tryNum == 0 then
                player.create_local_flying_text { text = "path test", position = transportChain.pathUnit.position, time_to_live = 15 }
            end
            if startingUnit:canConnect(transportChain.pathUnit) then
                transportChain:placeAllEntities(self.placeEntityFunc)
                logging.log("Path find algorithm explored " .. tostring(totalTryNum + tryNum) .. " blocks to find solution")
                foundPath = true
            end
            for _, pathUnit in pairs(self:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingUnit)) do
                local newChain = TransportChain.new(pathUnit, transportChain, preferOnGround)
                priorityQueue:push(self:estimateDistance(pathUnit, startingEntityTargetPos, startingUnit.direction) + newChain.cumulativeDistance, newChain)
            end
            tryNum = tryNum + 1
        end
        totalTryNum = totalTryNum + tryNum
        if priorityQueue:isEmpty() then
            self:debug_visited_position(minDistanceDict)
            reportToPlayer("Path finding terminated, there is probably no path between the two entity")
        elseif totalTryNum >= maxTryNum then
            self:debug_visited_position(minDistanceDict)
            reportToPlayer("Failed to connect transport line within " .. tostring(maxTryNum) .. " trials")
        elseif not foundPath then
            asyncTaskManager:pushTask(tryFindPath, taskPriority)
        end
    end
    asyncTaskManager:pushTask(tryFindPath, taskPriority)
end

--- @param transportChain TransportChain
--- @return PathUnit[]
function TransportLineConnector:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingEntity)
    assertNotNull(self, transportChain, minDistanceDict, allowUnderground, startingEntity)

    local candidates = transportChain.pathUnit:possiblePrevPathUnits(allowUnderground)

    local legalCandidates = ArrayList.new()
    for _, pathUnit in ipairs(candidates) do
        if self:testCanPlace(pathUnit, transportChain.cumulativeDistance + pathUnit.distance, minDistanceDict, startingEntity, transportChain) then
            legalCandidates:add(pathUnit)
        end
    end
    return legalCandidates
end

--- @param pathUnit PathUnit
--- @param cumulativeDistance number
--- @param minDistanceDict MinDistanceDict
--- @param startingEntity LuaEntitySpec
--- @param transportChain TransportChain
function TransportLineConnector:testCanPlace(pathUnit, cumulativeDistance, minDistanceDict, startingEntity, transportChain)
    assertNotNull(self, pathUnit, cumulativeDistance, minDistanceDict, startingEntity, transportChain)

    local entityList = pathUnit:toEntitySpecs()

    for _, entity in ipairs(entityList) do
        if not self.canPlaceEntityFunc(entity.position) then
            return false
        end
    end

    local attribute = EntityRoutingAttribute.from(pathUnit.name)
    if attribute.isUnderground then
        -- make sure there is no interfering underground belts whose direction is parallel to our underground belt pair
        for testDiff = 1, pathUnit.distance - 2, 1 do
            local testPos = pathUnit.position + Vector2D.fromDirection(pathUnit.direction):scale(testDiff)
            local entityInMiddle = self.getEntityFunc(testPos)
            if entityInMiddle
                    and (
                    entityInMiddle.name == pathUnit.name or
                            (entityInMiddle.type == "entity-ghost"
                                    and entityInMiddle.ghost_name == pathUnit.name
                            ))
                    and (((pathUnit.direction or defines.direction.north) - entityInMiddle.direction) % 4) == 0
            then
                logging.log("can't cross other entity facing" .. tostring(entityInMiddle.direction), "placing")
                return false
            end
        end
    end

    local closeToFinal = false
    for _, entity in ipairs(entityList) do
        if attribute.lineType == TransportLineType.itemLine then
            -- Check neighbor belts, make sure they don't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = EntityRoutingAttribute.from(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(neighbor) == entity.position then
                    if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                        logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                        return false
                    else
                        closeToFinal = true
                    end
                end
            end
        elseif attribute:isOnGroundPipe() then
            -- Check neighbor pipes, make sure pipe are not our neighbor and underground pipe doesn't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = EntityRoutingAttribute.from(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.fluidLine then
                    if neighborType.isUnderground == false or DirectionHelper.targetPositionOf(neighbor) == entity.position then
                        if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                            logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                            return false
                        else
                            closeToFinal = true
                        end
                    end
                end
            end
        end
    end

    if closeToFinal then
        return true
    else
        -- we only consider those path whose distance could be smaller at the position, like dijkstra algorithm
        local distanceSmallerThanAny = false
        for _, sourceUnit in ipairs(pathUnit:possiblePrevPathUnits(false)) do
            local curMinDistance = minDistanceDict:get(sourceUnit.position, sourceUnit.direction)
            if curMinDistance == nil or curMinDistance > cumulativeDistance then
                minDistanceDict:put(sourceUnit.position, sourceUnit.direction, cumulativeDistance)
                distanceSmallerThanAny = true
            end
        end
        return distanceSmallerThanAny
    end
end

--- A* algorithm's heuristics cost
--- @param testPathUnit PathUnit
--- @param targetPos Vector2D
--- @param rewardDirection defines.direction
function TransportLineConnector:estimateDistance(testPathUnit, targetPos, rewardDirection)
    local dx = math.abs(testPathUnit.position.x - targetPos.x)
    local dy = math.abs(testPathUnit.position.y - targetPos.y)
    -- break A* cost tie by rewarding going to same x/y-level, but reward is no more than 1
    local positionReward = 1 / (dy + 1)
    -- direction becomes increasingly important as belt is closer to starting entity, but reward is no more than 1
    -- We punish reversed direction, and reward same direction
    local directionReward = -1 * ((testPathUnit.direction - rewardDirection) % 8 / 2 - 1) / (dx + dy + 1)
    logging.log("reward = " .. tostring(positionReward), "reward")
    return (dx + dy + 1 - positionReward - directionReward) * 1.1 -- slightly encourage greedy-first
end

--- @param minDistanceDict MinDistanceDict
function TransportLineConnector:debug_visited_position(minDistanceDict)
    if not release_mode then
        local posDict = {}
        minDistanceDict:forEach(
                function(vector, direction, val)
                    local key = tostring(vector.x) .. "," .. tostring(vector.y)
                    posDict[key] = posDict[key] or { vector = vector, directions = {} }
                    posDict[key].directions[direction] = val
                end)
        local directionMapping = { [0] = "N", [2] = "E", [4] = "S", [6] = "W" }
        for _, dict in pairs(posDict) do
            local vector = dict.vector
            local text = ""
            for direction, val in pairs(dict.directions) do
                text = text .. directionMapping[direction] .. tostring(val)
            end
            game.players[1].create_local_flying_text { text = text, position = vector, time_to_live = 100000, speed = 0.000001 }
        end
    end
end

--- @param additionalConfig LineConnectConfig nullable
--- @return boolean, boolean allowUnderground, preferOnGround
function TransportLineConnector:parseConfig(additionalConfig)
    local allowUnderground = true
    local preferOnGround = false
    if additionalConfig then
        if additionalConfig.allowUnderground ~= nil then
            allowUnderground = additionalConfig.allowUnderground
        end
        if additionalConfig.preferOnGround ~= nil then
            preferOnGround = additionalConfig.preferOnGround
        end
    end
    return allowUnderground, preferOnGround
end

return TransportLineConnector