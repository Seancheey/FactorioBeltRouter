---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
--- Terminology:
---     targetBelt/sourceBelt: If belt A is point towards belt B, then belt B is the targetBelt of A. reversely, belt A is belt B's sourceBelt
---     |->| |->| |->| for this situation, in terms of the belt in the middle, the 1st belt is its sourceBelt, and 3rd is its targetBelt

local assertNotNull = require("__MiscLib__/assert_not_null")
--- @type Logger
local logging = require("__MiscLib__/logging")
--- @type ArrayList
local ArrayList = require("__MiscLib__/array_list")
--- @type MinHeap
local MinHeap = require("__MiscLib__/minheap")
--- @type Vector2D
local Vector2D = require("__MiscLib__/vector2d")
--- @type PrototypeInfo
local PrototypeInfo = require("prototype_info")
local release_mode = require("release")
--- @type TransportLineType
local TransportLineType = require("transport_line_type")
--- @type PathUnit
local PathUnit = require("path_unit")
local DirectionHelper = {}

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.sourcePositionOf(entity)
    return DirectionHelper.sourcePosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.sourcePosition(position, direction)
    assert(position and direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north):reverse()
end

--- @param entity LuaEntity
--- @return Vector2D
function DirectionHelper.targetPositionOf(entity)
    return DirectionHelper.targetPosition(entity.position, entity.direction)
end

--- @param position Vector2D
--- @param direction defines.direction
--- @return Vector2D
function DirectionHelper.targetPosition(position, direction)
    return Vector2D.fromPosition(position) + Vector2D.fromDirection(direction or defines.direction.north)
end

--- @param position Vector2D
--- @param getEntityFunc fun()
--- @return LuaEntity[] | ArrayList
function DirectionHelper.neighboringEntities(position, getEntityFunc)
    local entities = ArrayList.new()
    for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
        local entity = getEntityFunc(Vector2D.fromDirection(direction) + position)
        if entity ~= nil then
            entities:add(entity)
        end
    end
    return entities
end

--- @param entity LuaEntity
--- @return LuaEntity[]|ArrayList entity with only direction and position
function DirectionHelper.legalSourcesOf(entity)
    assert(entity)
    local legalSources = ArrayList.new()
    -- TODO handle pipe situation
    if PrototypeInfo.is_underground_transport(entity.name) then
        -- underground belt's input only allows one direction
        legalSources:add { position = DirectionHelper.sourcePositionOf(entity), direction = entity.direction }
    else
        -- normal belts allows 3 directions
        local banDirection = Vector2D.fromDirection(entity.direction):reverse():toDirection()
        for _, direction in ipairs { defines.direction.north, defines.direction.east, defines.direction.south, defines.direction.west } do
            if direction ~= banDirection then
                legalSources:add { position = DirectionHelper.sourcePosition(entity.position, direction), direction = (direction + 4) % 8 }
            end
        end
    end
    return legalSources
end

--- Transport chain is an intermediate generated backward linked list that represents a whole transport line.
--- Each node in this linked list represents either one belt, or a pair of underground belt. (in this case the "entity" field represents the input belt, and output belt is inferred by entityDistance + direction)
--- @class TransportChain
--- @field pathUnit PathUnit
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @type TransportChain
local TransportChain = {}

--- @param pathUnit PathUnit
--- @param prevChain TransportChain
--- @return TransportChain
function TransportChain.new(pathUnit, prevChain)
    assertNotNull(pathUnit)
    return setmetatable({
        pathUnit = pathUnit,
        prevChain = prevChain,
        cumulativeDistance = prevChain and (prevChain.cumulativeDistance + pathUnit.distance) or 0,
    }, { __index = TransportChain })
end

--- @param placeFunc fun(entity: LuaEntityPrototype)
function TransportChain:placeAllEntities(placeFunc)
    local transportChain = self
    local place = function(entity)
        if transportChain.prevChain ~= nil then
            placeFunc(entity)
        end
    end
    while transportChain ~= nil do
        for _, entitySpec in ipairs(transportChain.pathUnit:toEntitySpecs()) do
            place(entitySpec)
        end
        transportChain = transportChain.prevChain
    end
end

--- Represents the dictionary of minimum travel distance from endingEntity to some belt (represented by a position vector + direction)
--- @class MinDistanceDict
--- @type MinDistanceDict
local MinDistanceDict = {}
MinDistanceDict.__directionNum = 8

--- @return MinDistanceDict
function MinDistanceDict.new()
    return setmetatable({}, { __index = MinDistanceDict })
end

function MinDistanceDict.__marshalize(vector, direction)
    return tostring(vector.x) .. '|' .. tostring(vector.y) .. '|' .. tostring(direction)
end

function MinDistanceDict.__unmarshalize(key)
    local sep1 = string.find(key, '|')
    local x = string.sub(key, 1, sep1 - 1)
    local sep2 = string.find(key, '|', sep1 + 1)
    local y = string.sub(key, sep1 + 1, sep2 - 1)
    local direction = string.sub(key, sep2 + 1, -1)
    return Vector2D.new(tonumber(x), tonumber(y)), tonumber(direction)
end

--- @param vector Vector2D
function MinDistanceDict:put(vector, direction, val)
    assertNotNull(self, vector, direction, val)
    local key = MinDistanceDict.__marshalize(vector, direction)
    self[key] = val
end

--- @return number
function MinDistanceDict:get(vector, direction)
    assertNotNull(self, vector, direction)

    return self[MinDistanceDict.__marshalize(vector, direction)]
end

--- @param f fun(key1:vector, key2: defines.direction, val:number)
function MinDistanceDict:forEach(f)
    for key, val in pairs(self) do
        local vector, direction = MinDistanceDict.__unmarshalize(key)
        f(vector, direction, val)
    end
end

--- An "Abstract" transport line connector
--- @class TransportLineConnector
--- @field asyncTaskManager AsyncTaskManager
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntityFunc fun(entity: LuaEntityPrototype)
--- @field getEntityFunc fun(position: Vector2D): LuaEntity
--- @type TransportLineConnector
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @param placeEntityFunc fun(entity: LuaEntityPrototype)
--- @param getEntityFunc fun(position: Vector2D): LuaEntity
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    assertNotNull(canPlaceEntityFunc, placeEntityFunc, getEntityFunc, asyncTaskManager)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc,
              getEntityFunc = getEntityFunc,
              asyncTaskManager = asyncTaskManager
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferHorizontal boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param asyncTaskManager AsyncTaskManager
--- @param additionalConfig LineConnectConfig optional
--- @param player LuaPlayer optional, player to inform when building finished
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, asyncTaskManager, additionalConfig, player)
    assertNotNull(self, startingEntity, endingEntity)
    local function reportToPlayer(text)
        if player then
            player.print(text)
        end
    end
    if not startingEntity.valid then
        reportToPlayer("starting line entity is no longer valid")
        return
    end
    if not endingEntity.valid then
        reportToPlayer("ending line entity is no longer valid")
        return
    end
    local onGroundVersion = TransportLineType.onGroundVersionOf(startingEntity.name)
    if not onGroundVersion then
        reportToPlayer("Can't find an above-ground version of this entity")
    end
    startingEntity = PathUnit:fromLuaEntity(startingEntity)
    endingEntity = PathUnit:fromLuaEntity(endingEntity, true)

    local allowUnderground = true
    if additionalConfig and additionalConfig.allowUnderground ~= nil then
        allowUnderground = additionalConfig.allowUnderground
    end
    local preferHorizontal = (additionalConfig and (additionalConfig.preferHorizontal ~= nil)) and additionalConfig.preferHorizontal or true
    local minDistanceDict = MinDistanceDict.new()
    local priorityQueue = MinHeap.new()

    -- Here starts the main logic of function

    local startingEntityTargetPos = TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(startingEntity) or startingEntity.position
    if not self.canPlaceEntityFunc(startingEntityTargetPos) and TransportLineType.getType(startingEntity.name).lineType == TransportLineType.itemLine then
        logging.log("starting entity's target position is blocked")
        return
    end
    -- A* algorithm starts from endingEntity so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingEntity))
    local maxTryNum = settings.get_player_settings(player)["max-path-finding-explore-num"].value
    local batchSize = settings.get_player_settings(player)["path-finding-test-per-tick"].value
    local totalTryNum = 0
    local taskPriority = game.tick
    local function tryFindPath()
        local foundPath = false
        local tryNum = 0
        while not priorityQueue:isEmpty() and tryNum < batchSize do
            --- @type TransportChain
            local transportChain = priorityQueue:pop().val
            if tryNum == 0 then
                player.create_local_flying_text { text = "path test", position = transportChain.pathUnit.position, time_to_live = 15 }
            end
            if startingEntity:canConnect(transportChain.pathUnit) then
                transportChain:placeAllEntities(self.placeEntityFunc)
                logging.log("Path find algorithm explored " .. tostring(totalTryNum + tryNum) .. " blocks to find solution")
                foundPath = true
            end
            for _, pathUnit in pairs(self:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingEntity)) do
                local newChain = TransportChain.new(pathUnit, transportChain)
                priorityQueue:push(self:estimateDistance(pathUnit:toEntitySpecs()[1], startingEntityTargetPos, startingEntity.direction, preferHorizontal, not preferHorizontal) + newChain.cumulativeDistance, newChain)
            end
            tryNum = tryNum + 1
        end
        totalTryNum = totalTryNum + tryNum
        if not foundPath and not priorityQueue:isEmpty() and totalTryNum < maxTryNum then
            asyncTaskManager:pushTask(tryFindPath, taskPriority)
        else
            if priorityQueue:isEmpty() then
                self:debug_visited_position(minDistanceDict)
                reportToPlayer("Path finding terminated, there is probably no path between the two entity")
            elseif totalTryNum >= maxTryNum then
                self:debug_visited_position(minDistanceDict)
                reportToPlayer("Failed to connect transport line within " .. tostring(maxTryNum) .. " trials")
            end
        end
    end
    asyncTaskManager:pushTask(tryFindPath, taskPriority)
end

--- @param transportChain TransportChain
--- @return PathUnit[]
function TransportLineConnector:surroundingCandidates(transportChain, minDistanceDict, allowUnderground, startingEntity)
    assertNotNull(self, transportChain, minDistanceDict, allowUnderground, startingEntity)

    local candidates = transportChain.pathUnit:possiblePrevPathUnits(allowUnderground)

    local legalCandidates = ArrayList.new()
    for _, pathUnit in ipairs(candidates) do
        if self:testCanPlace(pathUnit, transportChain.cumulativeDistance + pathUnit.distance, minDistanceDict, startingEntity, transportChain) then
            legalCandidates:add(pathUnit)
        end
    end
    return legalCandidates
end

--- @param pathUnit PathUnit
--- @param cumulativeDistance number
--- @param minDistanceDict MinDistanceDict
--- @param startingEntity LuaEntitySpec
--- @param transportChain TransportChain
function TransportLineConnector:testCanPlace(pathUnit, cumulativeDistance, minDistanceDict, startingEntity, transportChain)
    assertNotNull(self, pathUnit, cumulativeDistance, minDistanceDict, startingEntity, transportChain)

    local entityType = TransportLineType.getType(pathUnit.name)

    if entityType.groundType == TransportLineType.underGround then
        -- make sure there is no interfering underground belts whose direction is parallel to our underground belt pair
        for testDiff = 1, pathUnit.distance - 2, 1 do
            local testPos = pathUnit.position + Vector2D.fromDirection(pathUnit.direction):scale(testDiff)
            local entityInMiddle = self.getEntityFunc(testPos)
            if entityInMiddle
                    and (
                    entityInMiddle.name == pathUnit.name or
                            (entityInMiddle.type == "entity-ghost"
                                    and entityInMiddle.ghost_name == pathUnit.name
                            ))
                    and (((pathUnit.direction or defines.direction.north) - entityInMiddle.direction) % 4) == 0
            then
                logging.log("can't cross other entity facing" .. tostring(entityInMiddle.direction), "placing")
                return false
            end
        end
    end

    for _, entity in ipairs(pathUnit:toEntitySpecs()) do
        if not self.canPlaceEntityFunc(entity.position) then
            return false
        end
        if entityType.lineType == TransportLineType.itemLine then
            -- Check neighbor belts, make sure they don't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = TransportLineType.getType(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.itemLine and DirectionHelper.targetPositionOf(neighbor) == entity.position then
                    if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                        logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                        return false
                    else
                        return true
                    end
                end
            end
        elseif (entityType.lineType == TransportLineType.fluidLine and entityType.groundType == TransportLineType.onGround) then
            -- Check neighbor pipes, make sure pipe are not our neighbor and underground pipe doesn't face our path
            for _, neighbor in ipairs(DirectionHelper.neighboringEntities(entity.position, self.getEntityFunc)) do
                local neighborType = TransportLineType.getType(neighbor.name)
                if neighborType and neighborType.lineType == TransportLineType.fluidLine then
                    if neighborType.groundType == TransportLineType.onGround or DirectionHelper.targetPositionOf(neighbor) == entity.position then
                        if (neighbor.position - startingEntity.position):lInfNorm() > 0.5 then
                            logging.log("found interfere and avoid building at " .. serpent.line(entity.position), "placing")
                            return false
                        else
                            return true
                        end
                    end
                end
            end
        end
    end


    -- we only consider those path whose distance could be smaller at the position, like dijkstra algorithm
    local distanceSmallerThanAny = false
    for _, sourceEntity in ipairs(DirectionHelper.legalSourcesOf(pathUnit)) do
        local curMinDistance = minDistanceDict:get(sourceEntity.position, sourceEntity.direction)
        if curMinDistance == nil or curMinDistance > cumulativeDistance then
            minDistanceDict:put(sourceEntity.position, sourceEntity.direction, cumulativeDistance)
            distanceSmallerThanAny = true
        end
    end
    return distanceSmallerThanAny
end

--- A* algorithm's heuristics cost
--- @param testEntity LuaEntity
--- @param targetPos Vector2D
--- @param rewardDirection defines.direction
function TransportLineConnector:estimateDistance(testEntity, targetPos, rewardDirection, rewardHorizontalFirst, rewardVerticalFirst)
    local dx = math.abs(testEntity.position.x - targetPos.x)
    local dy = math.abs(testEntity.position.y - targetPos.y)
    -- break A* cost tie by rewarding going to same x/y-level, but reward is no more than 1
    local positionReward = (rewardHorizontalFirst and (1 / (dy + 1)) or 0) + (rewardVerticalFirst and (1 / (dx + 1)) or 0)
    -- direction becomes increasingly important as belt is closer to starting entity, but reward is no more than 1
    -- We punish reversed direction, and reward same direction
    local directionReward = -1 * ((testEntity.direction - rewardDirection) % 8 / 2 - 1) / (dx + dy + 1)
    logging.log("reward = " .. tostring(positionReward), "reward")
    return (dx + dy + 1 - positionReward - directionReward) * 1.1 -- slightly encourage greedy-first
end

--- @param minDistanceDict MinDistanceDict
function TransportLineConnector:debug_visited_position(minDistanceDict)
    if not release_mode then
        local posDict = {}
        minDistanceDict:forEach(
                function(vector, direction, val)
                    local key = tostring(vector.x) .. "," .. tostring(vector.y)
                    posDict[key] = posDict[key] or { vector = vector, directions = {} }
                    posDict[key].directions[direction] = val
                end)
        local directionMapping = { [0] = "N", [2] = "E", [4] = "S", [6] = "W" }
        for _, dict in pairs(posDict) do
            local vector = dict.vector
            local text = ""
            for direction, val in pairs(dict.directions) do
                text = text .. directionMapping[direction] .. tostring(val)
            end
            game.players[1].create_local_flying_text { text = text, position = vector, time_to_live = 100000, speed = 0.000001 }
        end
    end
end

return TransportLineConnector