---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 9/27/20 5:19 PM
---


local ArrayList = require("__MiscLib__/array_list")
local MinHeap = require("__MiscLib__/minheap")
local Vector2D = require("__MiscLib__/vector2d")
local assertNotNull = require("__MiscLib__/assert_not_null")
local logging = require("__MiscLib__/logging")
--- @type PrototypeInfo
local PrototypeInfo = require("prototype_info")

--- @class TransportChain
--- @field entity LuaEntity
--- @field entityDistance number
--- @field prevChain TransportChain
--- @field cumulativeDistance number
--- @type TransportChain
local TransportChain = {}

--- @param entity LuaEntityPrototype
--- @param prevChain TransportChain
--- @param travelDistance number
--- @return TransportChain
function TransportChain.new(entity, prevChain, travelDistance)
    travelDistance = travelDistance or 1
    return setmetatable({
        entity = entity,
        prevChain = prevChain,
        cumulativeDistance = prevChain and (prevChain.cumulativeDistance + travelDistance) or 0,
        entityDistance = travelDistance
    }, { __index = TransportChain })
end

--- @return LuaEntity[]|ArrayList
function TransportChain:toEntityList()
    local list = ArrayList.new()
    local currentChain = self
    while currentChain ~= nil do
        list:add(currentChain.entity)
        currentChain = currentChain.prevChain
    end
    return list
end

--- @class VectorDict
--- @type VectorDict
local VectorDict = {}

function VectorDict.new()
    return setmetatable({}, { __index = VectorDict })
end

--- @param vector Vector2D
function VectorDict:put(vector, val)
    assertNotNull(self, vector, val)
    if self[vector.x] == nil then
        self[vector.x] = {}
    end
    self[vector.x][vector.y] = val
end

function VectorDict:get(vector)
    if self[vector.x] == nil then
        return nil
    end
    return self[vector.x][vector.y]
end

function VectorDict:forEach(f)
    for x, ys in pairs(self) do
        for y, val in pairs(ys) do
            f(Vector2D.new(x, y), val)
        end
    end
end

--- @param transportChain TransportChain
--- @param placeFunc fun(entity: LuaEntityPrototype)
local function placeAllEntities(transportChain, placeFunc)
    while transportChain ~= nil do
        if game.entity_prototypes[transportChain.entity.name].max_underground_distance then
            transportChain.entity.type = "input"
            placeFunc(transportChain.entity)
            -- if the entity is underground line, also place its complement
            placeFunc {
                name = transportChain.entity.name,
                position = Vector2D.fromDirection(transportChain.entity.direction or defines.direction.north):scale(transportChain.entityDistance - 1) + Vector2D.fromPosition(transportChain.entity.position),
                direction = transportChain.entity.direction,
                type = "output"
            }
        else
            placeFunc(transportChain.entity)
        end
        transportChain = transportChain.prevChain
    end
end

local function debug_visited_position(connector, visitedPositions)
    visitedPositions:forEach(
            function(vector)
                if connector.canPlaceEntityFunc(vector) then
                    connector.placeEntityFunc({ name = "small-lamp", position = vector })
                end
            end)
end

--- @class TransportLineConnector
--- @field canPlaceEntityFunc fun(position: Vector2D): boolean
--- @field placeEntityFunc fun(entity: LuaEntityPrototype)

--- @type TransportLineConnector
local TransportLineConnector = {}

TransportLineConnector.__index = TransportLineConnector

--- @param canPlaceEntityFunc fun(position: Vector2D): boolean
--- @return TransportLineConnector
function TransportLineConnector.new(canPlaceEntityFunc, placeEntityFunc)
    assert(canPlaceEntityFunc and placeEntityFunc)
    return setmetatable(
            { canPlaceEntityFunc = canPlaceEntityFunc,
              placeEntityFunc = placeEntityFunc
            }, TransportLineConnector)
end

--- @class LineConnectConfig
--- @field allowUnderground boolean default true
--- @field preferHorizontal boolean default true

--- @param startingEntity LuaEntity
--- @param endingEntity LuaEntity
--- @param additionalConfig LineConnectConfig optional
function TransportLineConnector:buildTransportLine(startingEntity, endingEntity, additionalConfig)
    assertNotNull(self, startingEntity, endingEntity)
    startingEntity = {
        name = startingEntity.name,
        position = Vector2D.fromPosition(startingEntity.position),
        direction = startingEntity.direction or defines.direction.north
    }
    endingEntity = {
        name = endingEntity.name,
        position = Vector2D.fromPosition(endingEntity.position),
        direction = endingEntity.direction or defines.direction.north
    }
    local allowUnderground = true
    if additionalConfig and additionalConfig.allowUnderground ~= nil then
        allowUnderground = additionalConfig.allowUnderground
    end
    local preferHorizontal = (additionalConfig and (additionalConfig.preferHorizontal ~= nil)) and additionalConfig.preferHorizontal or true
    local visitedPositions = VectorDict.new()
    local priorityQueue = MinHeap.new()
    local startingEntityTargetPos = Vector2D.fromPosition(startingEntity.position) + Vector2D.fromDirection(startingEntity.direction or defines.direction.north)
    if not self.canPlaceEntityFunc(startingEntityTargetPos) then
        logging.log("starting entity's target position is blocked")
        return
    end
    -- A* algorithm starts from endingEntity so that we don't have to consider/change last belt's direction
    priorityQueue:push(0, TransportChain.new(endingEntity, nil))
    local maxTryNum = 1000000
    local tryNum = 0
    while not priorityQueue:isEmpty() and tryNum < maxTryNum do
        --- @type TransportChain
        local transportChain = priorityQueue:pop().val

        local continue = false
        if transportChain.entity.position == startingEntityTargetPos then
            -- make sure direction diff is no more than 90 deg for belts or 0 deg underground belt
            local isUnderground = PrototypeInfo.is_underground_transport(transportChain.entity.name)
            if isUnderground and transportChain.entity.direction == startingEntity.direction or not isUnderground and (transportChain.entity.direction - startingEntity.direction) % 8 <= 2 then
                placeAllEntities(transportChain, self.placeEntityFunc)
                logging.log("Algorithm explored " .. tostring(tryNum) .. " blocks to find solution")
                return
            else
                continue = true
            end
        end
        if not continue then
            for entity, travelDistance in pairs(self:surroundingCandidates(transportChain, visitedPositions, game.entity_prototypes[startingEntity.name], allowUnderground)) do
                assert(entity and travelDistance)
                local newChain = TransportChain.new(entity, transportChain, travelDistance)
                priorityQueue:push(self:estimateDistance(entity, startingEntityTargetPos, startingEntity.direction, preferHorizontal, not preferHorizontal) + newChain.cumulativeDistance, newChain)
                visitedPositions:put(transportChain.entity.position, newChain.cumulativeDistance)
            end
            tryNum = tryNum + 1
        end
    end
    if priorityQueue:isEmpty() then
        logging.log("finding terminated early since there is no more places to find")
    else
        logging.log("Failed to connect transport line within " .. tostring(maxTryNum) .. " trials")
    end
    return
end

--- @param basePrototype LuaEntityPrototype transport line's base entity prototype
--- @param transportChain TransportChain
--- @return table<LuaEntity, number> entity to its travel distance
function TransportLineConnector:surroundingCandidates(transportChain, visitedPositions, basePrototype, allowUnderground)
    assertNotNull(self, transportChain, basePrototype, allowUnderground)

    local underground_prototype = PrototypeInfo.underground_transport_prototype(basePrototype.name)
    --- @type table<LuaEntity, number>
    local candidates = {}
    --- @type table<defines.direction, boolean>
    local legalDirections
    if PrototypeInfo.is_underground_transport(transportChain.entity.name) then
        -- underground belt's input only allows one direction
        legalDirections = { [Vector2D.fromDirection(transportChain.entity.direction):reverse():toDirection()] = true }
    else
        -- normal belt would allow 3 legal directions
        legalDirections = {
            [defines.direction.north] = true,
            [defines.direction.west] = true,
            [defines.direction.south] = true,
            [defines.direction.east] = true
        }
        legalDirections[transportChain.entity.direction or defines.direction.north] = nil
    end
    for direction, _ in pairs(legalDirections) do
        local directionVector = Vector2D.fromDirection(direction)
        -- test if we can place it underground
        if allowUnderground then
            for underground_distance = underground_prototype.max_underground_distance + 1, 2, -1 do
                local inputUndergroundPos = directionVector:scale(underground_distance) + Vector2D.fromPosition(transportChain.entity.position)
                local outputUndergroundPos = directionVector + Vector2D.fromPosition(transportChain.entity.position)
                if self:canPlace(inputUndergroundPos, transportChain.cumulativeDistance + underground_distance, visitedPositions, transportChain.entity.position) and
                        self.canPlaceEntityFunc(outputUndergroundPos) then
                    candidates[{
                        name = underground_prototype.name,
                        direction = directionVector:reverse():toDirection(),
                        position = inputUndergroundPos
                    }] = underground_distance
                end
            end
        end
        -- test if we can place it on ground
        local onGroundPos = directionVector + Vector2D.fromPosition(transportChain.entity.position)
        if self:canPlace(onGroundPos, transportChain.cumulativeDistance + 1, visitedPositions, transportChain.entity.position) then
            candidates[{
                name = basePrototype.name,
                direction = directionVector:reverse():toDirection(),
                position = onGroundPos
            }] = 1
        end
    end
    return candidates
end

--- @param position Vector2D
--- @param visitedPositions VectorDict
function TransportLineConnector:canPlace(position, cumulativeDistance, visitedPositions, targetPos)
    assertNotNull(self, position, visitedPositions)
    local currentMinDistance = visitedPositions:get(targetPos)
    if currentMinDistance and currentMinDistance <= cumulativeDistance then
        return false
    end
    if not self.canPlaceEntityFunc(position) then
        return false
    end
    return true
end

--- A* algorithm's heuristics cost
--- @param testEntity LuaEntity
--- @param targetPos Vector2D
--- @param rewardDirection defines.direction
function TransportLineConnector:estimateDistance(testEntity, targetPos, rewardDirection, rewardHorizontalFirst, rewardVerticalFirst)
    local dx = math.abs(testEntity.position.x - targetPos.x)
    local dy = math.abs(testEntity.position.y - targetPos.y)
    -- break A* cost tie by rewarding going to same x/y-level, but reward is no more than 1
    local reward = (rewardHorizontalFirst and (1 / (dy + 1)) or 0) + (rewardVerticalFirst and (1 / (dx + 1)) or 0)
    -- direction becomes increasingly important as belt is closer to starting entity, but reward is no more than 1
    -- We punish reversed direction, and reward same direction
    local directionReward = -1 * ((testEntity.direction - rewardDirection) % 8 / 2 - 1) / (dx + dy + 1)
    logging.log("reward = " .. tostring(reward))
    return (dx + dy - reward - directionReward) * 1.5
end

return TransportLineConnector