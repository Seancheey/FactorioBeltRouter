---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by seancheey.
--- DateTime: 10/3/20 11:59 PM
---
--- This file, as name suggests, consists of "routing attributes" for different entities.
--- I categorize "routable entities" into 4 categories: above-ground, underground, splitter and pump
--- Each of them behaves a little bit different in path finding.
--- And entities are grouped together so that, for example, if a player choose a underground belt, we can know what kind of belt he/she actually wants
---
--- So I designed 2 classes:
---   1. TransportLineGroup, which describes the grouping of entities
---   2. EntityRoutingAttribute, which describes different entities' connectivity and its group
---

--- @type Logger
local logging = require("__MiscLib__/logging")
--- @type Vector2D
local Vector2D = require("__MiscLib__/vector2d")
--- @type EntityTransportType
local EntityTransportType = require("enum/entity_transport_type")
--- @type TransportLineType
local TransportLineType = require("enum/line_type")
--- @type DirectionHelper
local DirectionHelper = require("__MiscLib__/direction_helper")
--- @type ArrayList
local ArrayList = require("__MiscLib__/array_list")

local function log(message)
    logging.log(message, "transportType")
end

--- @class TransportLineGroup
--- @type TransportLineGroup
local TransportLineGroup = {}
TransportLineGroup.normalGroupDict = {}
TransportLineGroup.undergroundGroupDict = {}
TransportLineGroup.splitterGroupDict = {}
TransportLineGroup.pumpGroupDict = {}
TransportLineGroup.loaded = false

function TransportLineGroup.add(normal, underground, splitter, pump)
    assert(normal and underground)
    local group = {
        [EntityTransportType.onGround] = game.entity_prototypes[normal],
        [EntityTransportType.underground] = game.entity_prototypes[underground],
        [EntityTransportType.splitter] = game.entity_prototypes[splitter],
        [EntityTransportType.pump] = game.entity_prototypes[pump]
    }
    TransportLineGroup.normalGroupDict[normal] = group
    TransportLineGroup.undergroundGroupDict[underground] = group
    if splitter then
        TransportLineGroup.splitterGroupDict[splitter] = group
    end
    if pump then
        TransportLineGroup.pumpGroupDict[pump] = group
    end
end

function TransportLineGroup.tryLoadAllGroups()
    if TransportLineGroup.loaded then
        return
    end
    TransportLineGroup.loaded = true
    TransportLineGroup.add("transport-belt", "underground-belt", "splitter")
    TransportLineGroup.add("fast-transport-belt", "fast-underground-belt", "fast-splitter")
    TransportLineGroup.add("express-transport-belt", "express-underground-belt", "express-splitter")
    TransportLineGroup.add("pipe", "pipe-to-ground", nil, "pump")
    -- below starts mod entities handling
    TransportLineGroup.add("se-deep-space-transport-belt-black", "se-deep-space-underground-belt-black", "se-deep-space-splitter-black")
    TransportLineGroup.add("se-deep-space-transport-belt-blue", "se-deep-space-underground-belt-blue", "se-deep-space-splitter-blue")
    TransportLineGroup.add("se-deep-space-transport-belt-cyan", "se-deep-space-underground-belt-cyan", "se-deep-space-splitter-cyan")
    TransportLineGroup.add("se-deep-space-transport-belt-green", "se-deep-space-underground-belt-green", "se-deep-space-splitter-green")
    TransportLineGroup.add("se-deep-space-transport-belt-magenta", "se-deep-space-underground-belt-magenta", "se-deep-space-splitter-magenta")
    TransportLineGroup.add("se-deep-space-transport-belt-red", "se-deep-space-underground-belt-red", "se-deep-space-splitter-red")
    TransportLineGroup.add("se-deep-space-transport-belt-white", "se-deep-space-underground-belt-white", "se-deep-space-splitter-white")
    TransportLineGroup.add("se-deep-space-transport-belt-yellow", "se-deep-space-underground-belt-yellow", "se-deep-space-splitter-yellow")
    TransportLineGroup.add("se-space-pipe", "se-space-pipe-to-ground")
    TransportLineGroup.add("kr-steel-pipe", "kr-steel-pipe-to-ground", nil, "kr-steel-pump")
end

--- Special mod transport line mapping support. For mod belts, usually the function can automatically figure out the group.
--- @type table<string, string>
local specialTransportLineGroupMapping = {
    ["factory-input-pipe"] = "pipe",
    ["factory-output-pipe"] = "pipe"
}

--- @class EntityRoutingAttribute
--- @field lineType TransportLineType string
--- @field beltType EntityTransportType string
--- @field isUnderground boolean
--- @field entityName string
--- @field groundEntityPrototype LuaEntityPrototype
--- @field undergroundEntityPrototype LuaEntityPrototype
--- @type EntityRoutingAttribute
local EntityRoutingAttribute = {}

--- @param k string
function EntityRoutingAttribute.__index(t, k)
    if k == "groundEntityPrototype" then
        local prototype = EntityRoutingAttribute.onGroundVersion(t)
        if prototype == nil then
            log("even more weird")
        end
        return prototype
    elseif k == "undergroundEntityPrototype" then
        return EntityRoutingAttribute.undergroundVersion(t)
    end
    return EntityRoutingAttribute[k]
end

--- @param entity_name string
--- @return EntityRoutingAttribute|nil
function EntityRoutingAttribute.from(entity_name)
    assert(entity_name)

    local prototype = game.entity_prototypes[entity_name]
    if not prototype then
        log("prototype " .. entity_name .. " is not an entity prototype")
        return nil
    end
    --- @type EntityRoutingAttribute
    local type = { entityName = entity_name }
    if prototype.fluid_capacity > 0 then
        type.lineType = TransportLineType.fluidLine
    elseif prototype.belt_speed ~= nil then
        type.lineType = TransportLineType.itemLine
    end
    if not type.lineType then
        log("prototype " .. entity_name .. " is neither a belt nor a pipe")
        return nil
    end
    if type.lineType == TransportLineType.itemLine then
        if prototype.max_underground_distance ~= nil then
            type.beltType = EntityTransportType.underground
        elseif string.find(entity_name, "splitter") then
            type.beltType = EntityTransportType.splitter
        else
            type.beltType = EntityTransportType.onGround
        end
    elseif type.lineType == TransportLineType.fluidLine then
        if prototype.pumping_speed ~= nil then
            type.beltType = EntityTransportType.pump
        else
            type.beltType = EntityTransportType.pipe
        end
    end
    type.isUnderground = prototype.max_underground_distance ~= nil
    setmetatable(type, EntityRoutingAttribute)
    log("type of " .. entity_name .. " is " .. serpent.line(type))
    return type
end

function EntityRoutingAttribute:isOnGroundPipe()
    return not self.isUnderground and self.beltType == EntityTransportType.pipe
end

function EntityRoutingAttribute:isOnGroundBelt()
    return self.lineType == TransportLineType.itemLine and self.beltType == EntityTransportType.onGround
end

function EntityRoutingAttribute:isUndergroundPipe()
    return self.isUnderground and self.lineType == TransportLineType.fluidLine
end

function EntityRoutingAttribute:isUndergroundBelt()
    return self.isUnderground and self.lineType == TransportLineType.itemLine
end

function EntityRoutingAttribute:isSplitter()
    return self.beltType == EntityTransportType.splitter
end

function EntityRoutingAttribute:isPump()
    return self.beltType == EntityTransportType.pump
end

--- @return Vector2D
function EntityRoutingAttribute:snapToNearestPoint(position)
    return Vector2D.new(math.floor(position.x + 1) - 0.5, math.floor(position.y + 1) - 0.5)
end

--- @return Vector2D[] all points inscribed by the entity, which are snapped to (X.5, Y.5) where X,Y \in integer coordinate
function EntityRoutingAttribute:getAllPointPositions(position, direction)
    if not self:isPump() and not self:isSplitter() then
        return { position }
    end
    local normalizedStretchDirection = 0
    if self:isPump() then
        -- stretch bounding box along direction
        normalizedStretchDirection = (direction - 2) % 4 + 2
    elseif self:isSplitter() then
        -- stretch bounding box along perpendicular direction
        normalizedStretchDirection = direction % 4 + 2
    end
    local centerPos = Vector2D.fromPosition(position)
    local startPosDelta = Vector2D.fromDirection(normalizedStretchDirection):scale(0.5):reverse()
    local endPosDelta = Vector2D.fromDirection(normalizedStretchDirection):scale(0.5)
    local startingPos = self:snapToNearestPoint(centerPos + startPosDelta)
    local endingPos = self:snapToNearestPoint(centerPos + endPosDelta)
    local positions = ArrayList.new()
    for y = startingPos.y, endingPos.y do
        for x = startingPos.x, endingPos.x do
            positions:add(Vector2D.new(x, y))
        end
    end
    return positions
end

--- @type table<fun(attribute: EntityRoutingAttribute):boolean, fun(direction: defines.direction):defines.direction[]>
local nextDisplacements = {
    isOnGroundPipe = DirectionHelper.listAllStraightDirectionOf,
    isOnGroundBelt = DirectionHelper.listFrontOf,
    isUndergroundPipe = DirectionHelper.listFrontOf,
    isUndergroundBelt = DirectionHelper.listFrontOf,
    isPump = DirectionHelper.listFrontOf,
    isSplitter = DirectionHelper.listFrontOf,
}

--- @type table<fun(attribute: EntityRoutingAttribute):boolean, fun(direction: defines.direction):defines.direction[]>
local prevDisplacements = {
    isOnGroundPipe = DirectionHelper.listAllStraightDirectionOf,
    isOnGroundBelt = DirectionHelper.listTailLeftRightOf,
    isUndergroundPipe = DirectionHelper.listReverseOf,
    isUndergroundBelt = DirectionHelper.listReverseOf,
    isPump = DirectionHelper.listReverseOf,
    isSplitter = DirectionHelper.listReverseOf,
}

--- @return defines.direction[]
function EntityRoutingAttribute:nextPossibleDisplacements(direction)
    for attributeCriteriaFunc, displacementFunc in pairs(nextDisplacements) do
        if EntityRoutingAttribute[attributeCriteriaFunc](self) then
            return displacementFunc(direction)
        end
    end
    logging.log("Unable to find nextPossibleDisplacements of " .. self.entityName)
    return direction
end

--- @return defines.direction[]
function EntityRoutingAttribute:prevPossibleDisplacements(direction)
    for attributeCriteriaFunc, displacementFunc in pairs(prevDisplacements) do
        if EntityRoutingAttribute[attributeCriteriaFunc](self) then
            return displacementFunc(direction)
        end
    end
    logging.log("Unable to find prevPossibleDisplacements of " .. self.entityName)
    return DirectionHelper.reverseOf(direction)
end

--- @return LuaEntityPrototype|nil
function EntityRoutingAttribute:onGroundVersion()
    TransportLineGroup.tryLoadAllGroups()
    local lineGroup = EntityRoutingAttribute.getLineGroup(self)
    if lineGroup then
        return lineGroup[EntityTransportType.onGround]
    end
end

--- @return LuaEntityPrototype|nil
function EntityRoutingAttribute:undergroundVersion()
    TransportLineGroup.tryLoadAllGroups()
    local lineGroup = EntityRoutingAttribute.getLineGroup(self)
    if lineGroup then
        return lineGroup[EntityTransportType.underground]
    end
end

--- @return TransportLineGroup
function EntityRoutingAttribute:getLineGroup()
    local entity_name = self.entityName
    if specialTransportLineGroupMapping[self.entityName] then
        log("Mapped special item " .. self.entityName .. "'s type to " .. specialTransportLineGroupMapping[entity_name])
        entity_name = specialTransportLineGroupMapping[entity_name]
    end
    for _, dict in ipairs { TransportLineGroup.normalGroupDict, TransportLineGroup.undergroundGroupDict, TransportLineGroup.splitterGroupDict, TransportLineGroup.pumpGroupDict } do
        if dict[entity_name] then
            return dict[entity_name]
        end
    end
    log("Failed to find entity " .. self.entityName .. "'s line group, trying to infer one")
    return self:inferLineGroup(entity_name)
end

--- when an entity's group is not found, we infer its group from its attributes (like belt speed and entity name)
function EntityRoutingAttribute:inferLineGroup(entity_name)
    if EntityRoutingAttribute.from(entity_name).lineType == TransportLineType.itemLine then
        local groupBeltSpeed = game.entity_prototypes[entity_name].belt_speed
        assert(groupBeltSpeed, " item line is supposed to have belt speed, but \"" .. entity_name .. "\" doesn't?")
        local beltVersion, undergroundVersion, splitterVersion
        for _, entityPrototype in pairs(game.entity_prototypes) do
            if entityPrototype.belt_speed == groupBeltSpeed then
                if entityPrototype.max_underground_distance then
                    undergroundVersion = entityPrototype
                    -- TODO: find a better way of classifying splitter
                elseif string.find(entityPrototype.name, "splitter") then
                    splitterVersion = entityPrototype
                else
                    beltVersion = entityPrototype
                end

                if undergroundVersion and splitterVersion and beltVersion then
                    break
                end
            end
        end
        log("Found mod belt group: " .. beltVersion.name .. ", " .. undergroundVersion.name .. ", " .. splitterVersion.name)
        TransportLineGroup.add(beltVersion.name, undergroundVersion.name, splitterVersion.name)
        return {
            [EntityTransportType.onGround] = beltVersion,
            [EntityTransportType.underground] = undergroundVersion,
            [EntityTransportType.splitter] = splitterVersion,
        }
    elseif EntityRoutingAttribute.from(entity_name).lineType == TransportLineType.fluidLine then
        if EntityRoutingAttribute.from(entity_name).isUnderground == false then
            -- TODO should find a way of associate fluid pipe's group
            return {
                [EntityTransportType.onGround] = game.entity_prototypes[entity_name],
                [EntityTransportType.underground] = game.entity_prototypes["pipe-to-ground"],
            }
        end
        -- By default, assume on ground is pipe, underground is pipe-to-ground
    end
    log("failed to find line group of " .. entity_name)
    return nil
end

return EntityRoutingAttribute